--------------------------------------------------------------------------------
Profile data file 'xtmemory_20251209_181912.kcg' (creator: xtree-1)
--------------------------------------------------------------------------------
Profiled target:  ./lab3 (PID 22245)
Events recorded:  curB curBk totB totBk totFdB totFdBk
Events shown:     curB curBk totB totBk totFdB totFdBk
Event sort order: curB curBk totB totBk totFdB totFdBk
Thresholds:       99 0 0 0 0 0
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
curB       curBk      totB           totBk       totFdB         totFdBk     
--------------------------------------------------------------------------------
0          0          2,828 (100.0%) 40 (100.0%) 2,828 (100.0%) 40 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
curB       curBk      totB           totBk       totFdB         totFdBk      file:function
--------------------------------------------------------------------------------
0          0          2,828 (100.0%) 40 (100.0%)   780 (27.58%) 38 (95.00%)  /home/yama/documents/leti/AiSD/lab3/main.c:main
0          0          2,048 (72.42%)  2 ( 5.00%)     0           0           ./libio/./libio/filedoalloc.c:_IO_file_doallocate
0          0          2,048 (72.42%)  2 ( 5.00%)     0           0           ./libio/./libio/genops.c:_IO_doallocbuf
0          0          1,456 (51.49%) 25 (62.50%)   432 (15.28%) 24 (60.00%)  /home/yama/documents/leti/AiSD/lab3/src/test.c:manual_test
0          0          1,372 (48.51%) 15 (37.50%)   348 (12.31%) 14 (35.00%)  /home/yama/documents/leti/AiSD/lab3/src/test.c:input_test
0          0          1,024 (36.21%)  1 ( 2.50%)     0           0           ./libio/./libio/fileops.c:_IO_file_overflow@@GLIBC_2.2.5
0          0          1,024 (36.21%)  1 ( 2.50%)     0           0           ./libio/./libio/fileops.c:_IO_file_underflow@@GLIBC_2.2.5
0          0          1,024 (36.21%)  1 ( 2.50%)     0           0           ./libio/./libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5
0          0          1,024 (36.21%)  1 ( 2.50%)     0           0           ./libio/./libio/genops.c:_IO_default_uflow
0          0          1,024 (36.21%)  1 ( 2.50%)     0           0           ./libio/./libio/ioputs.c:puts
0          0          1,024 (36.21%)  1 ( 2.50%)     0           0           ./stdio-common/./stdio-common/isoc99_scanf.c:__isoc99_scanf
0          0          1,024 (36.21%)  1 ( 2.50%)     0           0           ./stdio-common/./stdio-common/vfscanf-internal.c:__vfscanf_internal
0          0            408 (14.43%) 25 (62.50%)     0           0           /home/yama/documents/leti/AiSD/lab3/src/polynomial.c:new_pol
0          0            360 (12.73%) 10 (25.00%)   296 (10.47%) 10 (25.00%)  /home/yama/documents/leti/AiSD/lab3/src/polynomial.c:pol_mul_mod_unit
0          0            144 ( 5.09%)  6 (15.00%)    96 ( 3.39%)  6 (15.00%)  /home/yama/documents/leti/AiSD/lab3/src/string_utils.c:str_to_pol
0          0            112 ( 3.96%)  3 ( 7.50%)   112 ( 3.96%)  3 ( 7.50%)  /home/yama/documents/leti/AiSD/lab3/src/polynomial.c:pol_mul_pol
0          0            112 ( 3.96%)  3 ( 7.50%)    48 ( 1.70%)  3 ( 7.50%)  /home/yama/documents/leti/AiSD/lab3/src/polynomial.c:modulo_unit_pol
0          0            112 ( 3.96%)  3 ( 7.50%)    48 ( 1.70%)  3 ( 7.50%)  /home/yama/documents/leti/AiSD/lab3/src/polynomial.c:realloc_coeffs
0          0              4 ( 0.14%)  1 ( 2.50%)     0           0           /home/yama/documents/leti/AiSD/lab3/src/string_utils.c:pol_to_str
0          0              0           0          2,048 (72.42%)  2 ( 5.00%)  ./csu/../sysdeps/nptl/libc_start_call_main.h:(below main)
0          0              0           0          2,048 (72.42%)  2 ( 5.00%)  ./libio/./libio/genops.c:__libio_freemem
0          0              0           0          2,048 (72.42%)  2 ( 5.00%)  ./malloc/./malloc/set-freeres.c:__libc_freeres
0          0              0           0          2,048 (72.42%)  2 ( 5.00%)  ./stdlib/./stdlib/exit.c:__run_exit_handlers
0          0              0           0          2,048 (72.42%)  2 ( 5.00%)  ./stdlib/./stdlib/exit.c:exit
0          0              0           0          2,048 (72.42%)  2 ( 5.00%)  UnknownFile???:_vgnU_freeres
0          0              0           0            520 (18.39%) 25 (62.50%)  /home/yama/documents/leti/AiSD/lab3/src/polynomial.c:free_pol

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/yama/documents/leti/AiSD/lab3/src/polynomial.c
--------------------------------------------------------------------------------
curB       curBk      totB         totBk       totFdB       totFdBk     

.          .            .           .            .           .           #include "../include/polynomial.h"
.          .            .           .            .           .           
.          .            .           .            .           .           /*--------------------- ВСПОМОГАТЕЛЬНЫЕ ОПЕРАЦИИ ---------------------*/
.          .            .           .            .           .           
.          .            .           .            .           .           int realloc_coeffs(Polynomial* R, size_t required_degree)
.          .            .           .            .           .           {
.          .            .           .            .           .               if (R->coeffs == NULL || R->degree < required_degree)
.          .            .           .            .           .               {
0          0          112 ( 3.96%)  3 ( 7.50%)   0           0                   ULL *new_coeffs = calloc(required_degree + 1, sizeof(ULL));
.          .            .           .            .           .                   if (new_coeffs == NULL)
.          .            .           .            .           .                       return POL_MEMORY_ERROR;
.          .            .           .            .           .           
.          .            .           .            .           .                   if (R->coeffs != NULL)
0          0            0           0           48 ( 1.70%)  3 ( 7.50%)              free(R->coeffs);
.          .            .           .            .           .           
.          .            .           .            .           .                   R->coeffs = new_coeffs;
.          .            .           .            .           .               }
.          .            .           .            .           .               return POL_SUCCESS;
.          .            .           .            .           .           }
.          .            .           .            .           .           
.          .            .           .            .           .           int set_pol_params(Polynomial *R, size_t deg, ULL modulo)
.          .            .           .            .           .           {
-- line 22 ----------------------------------------
-- line 101 ----------------------------------------
.          .            .           .            .           .                   return POL_NULL_PTR;
.          .            .           .            .           .               }
.          .            .           .            .           .           
.          .            .           .            .           .               if (modulo <= 1)
.          .            .           .            .           .               {
.          .            .           .            .           .                   return POL_INVALID_MODULO;
.          .            .           .            .           .               }
.          .            .           .            .           .           
0          0          408 (14.43%) 25 (62.50%)   0           0               p->coeffs = calloc(degree + 1, sizeof(ULL));
.          .            .           .            .           .               if (p->coeffs == NULL)
.          .            .           .            .           .               {
.          .            .           .            .           .                   return POL_MEMORY_ERROR;
.          .            .           .            .           .               }
.          .            .           .            .           .           
.          .            .           .            .           .               set_pol_params(p, degree, modulo);
.          .            .           .            .           .           
.          .            .           .            .           .               return POL_SUCCESS;
-- line 117 ----------------------------------------
-- line 121 ----------------------------------------
.          .            .           .            .           .           {
.          .            .           .            .           .               if (p == NULL)
.          .            .           .            .           .               {
.          .            .           .            .           .                   return;
.          .            .           .            .           .               }
.          .            .           .            .           .           
.          .            .           .            .           .               if (p->coeffs != NULL)
.          .            .           .            .           .               {
0          0            0           0          520 (18.39%) 25 (62.50%)          free(p->coeffs);
.          .            .           .            .           .                   p->coeffs = NULL;
.          .            .           .            .           .               }
.          .            .           .            .           .           
.          .            .           .            .           .               set_pol_params(p, 0, 0);
.          .            .           .            .           .           }
.          .            .           .            .           .           
.          .            .           .            .           .           int copy_pol(const Polynomial *src, Polynomial *dst)
.          .            .           .            .           .           {
-- line 137 ----------------------------------------
-- line 321 ----------------------------------------
.          .            .           .            .           .               {
.          .            .           .            .           .                   set_pol_params(R, 0, A->modulo);
.          .            .           .            .           .                   R->coeffs[0] = 0;
.          .            .           .            .           .                   return POL_SUCCESS;
.          .            .           .            .           .               }
.          .            .           .            .           .           
.          .            .           .            .           .               size_t result_degree = A->degree + B->degree;
.          .            .           .            .           .           
0          0          112 ( 3.96%)  3 ( 7.50%)   0           0               ULL* temp_coeffs = calloc(result_degree + 1, sizeof(ULL));
.          .            .           .            .           .               if (temp_coeffs == NULL) return POL_MEMORY_ERROR;
.          .            .           .            .           .           
.          .            .           .            .           .               ULL m = A->modulo;
.          .            .           .            .           .           
.          .            .           .            .           .               for (size_t i = 0; i <= A->degree; i++)
.          .            .           .            .           .               {
.          .            .           .            .           .                   ULL a = A->coeffs[i];
.          .            .           .            .           .                   if (a == 0) continue;
-- line 337 ----------------------------------------
-- line 345 ----------------------------------------
.          .            .           .            .           .                   }
.          .            .           .            .           .               }
.          .            .           .            .           .           
.          .            .           .            .           .               set_pol_params(R, result_degree, A->modulo);
.          .            .           .            .           .           
.          .            .           .            .           .               for (size_t i = 0; i <= result_degree; i++)
.          .            .           .            .           .                   R->coeffs[i] = temp_coeffs[i];
.          .            .           .            .           .           
0          0            0           0          112 ( 3.96%)  3 ( 7.50%)      free(temp_coeffs);
.          .            .           .            .           .               normalize_pol(R);
.          .            .           .            .           .               return POL_SUCCESS;
.          .            .           .            .           .           }
.          .            .           .            .           .           
.          .            .           .            .           .           /* Остаток полиномиального деления: R = A modulo M */
.          .            .           .            .           .           int modulo_unit_pol(const Polynomial* A, const Polynomial* M, Polynomial* R)
.          .            .           .            .           .           {
.          .            .           .            .           .               if (A == NULL || M == NULL || R == NULL)
-- line 361 ----------------------------------------
-- line 370 ----------------------------------------
.          .            .           .            .           .           
.          .            .           .            .           .               ULL m = A->modulo;
.          .            .           .            .           .           
.          .            .           .            .           .               if (M->degree == 0 && M->coeffs[0] == 0)
.          .            .           .            .           .               {
.          .            .           .            .           .                   return POL_ZERO_DIV;
.          .            .           .            .           .               }
.          .            .           .            .           .           
0          0          112 ( 3.96%)  3 ( 7.50%)  48 ( 1.70%)  3 ( 7.50%)      realloc_coeffs(R, A->degree);
.          .            .           .            .           .               set_pol_params(R, A->degree, m);
.          .            .           .            .           .           
.          .            .           .            .           .               for (size_t i = 0; i <= A->degree; i++)
.          .            .           .            .           .                   R->coeffs[i] = A->coeffs[i] % m;
.          .            .           .            .           .           
.          .            .           .            .           .               normalize_pol(R);
.          .            .           .            .           .           
.          .            .           .            .           .               ULL lead = M->coeffs[M->degree] % m;
-- line 386 ----------------------------------------
-- line 425 ----------------------------------------
.          .            .           .            .           .               if (M->degree == 0 && M->coeffs[0] == 0)
.          .            .           .            .           .                   return POL_ZERO_DIV;
.          .            .           .            .           .           
.          .            .           .            .           .               if (M->coeffs[M->degree] != 1)
.          .            .           .            .           .                   return POL_INVALID_ARG;
.          .            .           .            .           .           
.          .            .           .            .           .               Polynomial T;
.          .            .           .            .           .           
0          0          136 ( 4.81%)  4 (10.00%)   0           0               new_pol(&T, A->degree + B->degree, A->modulo);
.          .            .           .            .           .           
0          0          112 ( 3.96%)  3 ( 7.50%) 112 ( 3.96%)  3 ( 7.50%)      int status = pol_mul_pol(A, B, &T);
.          .            .           .            .           .               if (status != POL_SUCCESS)
.          .            .           .            .           .               {
.          .            .           .            .           .                   free_pol(&T);
.          .            .           .            .           .                   return status;
.          .            .           .            .           .               }
0          0          112 ( 3.96%)  3 ( 7.50%)  48 ( 1.70%)  3 ( 7.50%)      status = modulo_unit_pol(&T, M, R);
.          .            .           .            .           .           
0          0            0           0          136 ( 4.81%)  4 (10.00%)      free_pol(&T);
.          .            .           .            .           .               return status;
.          .            .           .            .           .           }
--------------------------------------------------------------------------------
-- Auto-annotated source: /home/yama/documents/leti/AiSD/lab3/src/string_utils.c
--------------------------------------------------------------------------------
curB       curBk      totB        totBk      totFdB      totFdBk    

-- line 2 ----------------------------------------
.          .           .          .           .          .           
.          .           .          .           .          .           int str_to_pol(const char* str, ULL modulo, Polynomial* pol)
.          .           .          .           .          .           {
.          .           .          .           .          .               if (!str || !pol) return POL_NULL_PTR;
.          .           .          .           .          .               if (modulo <= 1) return POL_INVALID_MODULO;
.          .           .          .           .          .           
.          .           .          .           .          .               if (pol->coeffs != NULL)
.          .           .          .           .          .               {
0          0           0          0          24 ( 0.85%) 3 ( 7.50%)          free(pol->coeffs);
.          .           .          .           .          .               }
.          .           .          .           .          .               set_pol_params(pol, 0, modulo);
.          .           .          .           .          .           
.          .           .          .           .          .               while (*str == ' ') str++;
.          .           .          .           .          .           
.          .           .          .           .          .               if (*str++ != '(') return POL_INVALID_ARG;
.          .           .          .           .          .           
.          .           .          .           .          .               // Считаем запятые
-- line 18 ----------------------------------------
-- line 20 ----------------------------------------
.          .           .          .           .          .               const char* p = str;
.          .           .          .           .          .               while (*p && *p != ')')
.          .           .          .           .          .               {
.          .           .          .           .          .                   if (*p == ',') count++;
.          .           .          .           .          .                   p++;
.          .           .          .           .          .               }
.          .           .          .           .          .               if (*p != ')') return POL_INVALID_ARG;
.          .           .          .           .          .           
0          0          72 ( 2.55%) 3 ( 7.50%)  0          0               ULL* coeffs = malloc(count * sizeof(ULL));
.          .           .          .           .          .               if (!coeffs) return POL_MEMORY_ERROR;
.          .           .          .           .          .           
.          .           .          .           .          .               p = str;
.          .           .          .           .          .               for (size_t i = 0; i < count; i++)
.          .           .          .           .          .               {
.          .           .          .           .          .                   // Пропускаем пробелы
.          .           .          .           .          .                   while (*p == ' ') p++;
.          .           .          .           .          .           
-- line 36 ----------------------------------------
-- line 82 ----------------------------------------
.          .           .          .           .          .               }
.          .           .          .           .          .           
.          .           .          .           .          .               // Убираем ведущие нули
.          .           .          .           .          .               size_t degree = count - 1;
.          .           .          .           .          .               while (degree > 0 && coeffs[degree] == 0)
.          .           .          .           .          .                   degree--;
.          .           .          .           .          .           
.          .           .          .           .          .               // Выделяем память для результата
0          0          72 ( 2.55%) 3 ( 7.50%)  0          0               ULL* result_coeffs = malloc((degree + 1) * sizeof(ULL));
.          .           .          .           .          .               if (!result_coeffs)
.          .           .          .           .          .               {
.          .           .          .           .          .                   free(coeffs);
.          .           .          .           .          .                   return POL_MEMORY_ERROR;
.          .           .          .           .          .               }
.          .           .          .           .          .           
.          .           .          .           .          .               for (size_t i = 0; i <= degree; i++)
.          .           .          .           .          .                   result_coeffs[i] = coeffs[i];
.          .           .          .           .          .           
0          0           0          0          72 ( 2.55%) 3 ( 7.50%)      free(coeffs);
.          .           .          .           .          .           
.          .           .          .           .          .               set_pol_params(pol, degree, modulo);
.          .           .          .           .          .               pol->coeffs = result_coeffs;
.          .           .          .           .          .           
.          .           .          .           .          .               return POL_SUCCESS;
.          .           .          .           .          .           }
.          .           .          .           .          .           
.          .           .          .           .          .           int pol_to_str(const Polynomial* pol, char** str)
-- line 108 ----------------------------------------
-- line 120 ----------------------------------------
.          .           .          .           .          .                   ULL num = pol->coeffs[i];
.          .           .          .           .          .                   do {
.          .           .          .           .          .                       total_len++;
.          .           .          .           .          .                   } while (num /= 10);
.          .           .          .           .          .           
.          .           .          .           .          .                   if (i < pol->degree) total_len++; // запятая
.          .           .          .           .          .               }
.          .           .          .           .          .           
0          0           4 ( 0.14%) 1 ( 2.50%)  0          0               *str = malloc(total_len + 1);
.          .           .          .           .          .               if (*str == NULL)
.          .           .          .           .          .                   return POL_MEMORY_ERROR;
.          .           .          .           .          .           
.          .           .          .           .          .               char* pos = *str;
.          .           .          .           .          .               *pos++ = '(';
.          .           .          .           .          .           
.          .           .          .           .          .               for (size_t i = 0; i <= pol->degree; i++)
.          .           .          .           .          .               {
-- line 136 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/yama/documents/leti/AiSD/lab3/main.c
--------------------------------------------------------------------------------
curB       curBk      totB           totBk       totFdB       totFdBk     

.          .              .           .            .           .           #include "include/test.h"
.          .              .           .            .           .           
.          .              .           .            .           .           int main()
.          .              .           .            .           .           {
0          0          1,456 (51.49%) 25 (62.50%) 432 (15.28%) 24 (60.00%)      manual_test();
.          .              .           .            .           .               printf("\n");
.          .              .           .            .           .               printf("\n");
0          0          1,372 (48.51%) 15 (37.50%) 348 (12.31%) 14 (35.00%)      input_test();
.          .              .           .            .           .               printf("\n");
.          .              .           .            .           .               printf("\n");
.          .              .           .            .           .               auto_test();
.          .              .           .            .           .               return 0;
.          .              .           .            .           .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/yama/documents/leti/AiSD/lab3/src/test.c
--------------------------------------------------------------------------------
curB       curBk      totB           totBk      totFdB       totFdBk    

-- line 3 ----------------------------------------
.          .              .          .            .          .           #define MAX_INPUT_LEN 1024
.          .              .          .            .          .           
.          .              .          .            .          .           size_t maxMemory = 0;
.          .              .          .            .          .           size_t currentMemory = 0;
.          .              .          .            .          .           
.          .              .          .            .          .           
.          .              .          .            .          .           int manual_test()
.          .              .          .            .          .           {
0          0          1,024 (36.21%) 1 ( 2.50%)   0          0               printf("=== Тестирование pol_mul_mod_unit ===\n\n");
.          .              .          .            .          .           
.          .              .          .            .          .               int test_count = 0;
.          .              .          .            .          .               int passed_count = 0;
.          .              .          .            .          .               Polynomial A, B, M, R;
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0               new_pol(&R, 0, 2);
.          .              .          .            .          .               // ----- ТЕСТ 1: обычное корректное вычисление -----
.          .              .          .            .          .               {
.          .              .          .            .          .                   test_count++;
.          .              .          .            .          .                   printf("[TEST 1] Обычное корректное вычисление\n");
.          .              .          .            .          .           
.          .              .          .            .          .           
0          0             24 ( 0.85%) 1 ( 2.50%)   0          0                   new_pol(&A, 2, 7);  // A = x^2 + 2x + 3 в Z7
.          .              .          .            .          .                   A.coeffs[0] = 3; A.coeffs[1] = 2; A.coeffs[2] = 1;
.          .              .          .            .          .           
0          0             16 ( 0.57%) 1 ( 2.50%)   0          0                   new_pol(&B, 1, 7);  // B = x + 4 в Z7
.          .              .          .            .          .                   B.coeffs[0] = 4; B.coeffs[1] = 1;
.          .              .          .            .          .           
0          0             24 ( 0.85%) 1 ( 2.50%)   0          0                   new_pol(&M, 2, 7);  // M = x^2 + 1 (унитарный)
.          .              .          .            .          .                   M.coeffs[0] = 1; M.coeffs[1] = 0; M.coeffs[2] = 1;
.          .              .          .            .          .           
.          .              .          .            .          .                   // Ожидаем: (x^2+2x+3)(x+4) mod (x^2+1) = 3x + 5 в Z7
.          .              .          .            .          .                   Polynomial expected;
0          0             16 ( 0.57%) 1 ( 2.50%)   0          0                   new_pol(&expected, 1, 7);
.          .              .          .            .          .                   expected.coeffs[0] = 6; expected.coeffs[1] = 3;
.          .              .          .            .          .           
0          0             96 ( 3.39%) 3 ( 7.50%)  72 ( 2.55%) 3 ( 7.50%)          int result = pol_mul_mod_unit(&A, &B, &M, &R);
.          .              .          .            .          .           
.          .              .          .            .          .                   printf("  Вход: A="); print_polynomial(&A, "");
.          .              .          .            .          .                   printf("        B="); print_polynomial(&B, "");
.          .              .          .            .          .                   printf("        M="); print_polynomial(&M, "");
.          .              .          .            .          .                   printf("  Ожидаем: "); print_polynomial(&expected, "");
.          .              .          .            .          .                   printf("  Получили: "); print_polynomial(&R, "");
.          .              .          .            .          .                   printf("  Статус: %d", result);
.          .              .          .            .          .           
-- line 45 ----------------------------------------
-- line 51 ----------------------------------------
.          .              .          .            .          .                       printf(" -> ПРОЙДЕН\n");
.          .              .          .            .          .                       passed_count++;
.          .              .          .            .          .                   }
.          .              .          .            .          .                   else
.          .              .          .            .          .                   {
.          .              .          .            .          .                       printf(" -> ПРОВАЛ\n");
.          .              .          .            .          .                   }
.          .              .          .            .          .           
0          0              0          0           80 ( 2.83%) 4 (10.00%)          free_pol(&A); free_pol(&B); free_pol(&M); free_pol(&expected);
.          .              .          .            .          .               }
.          .              .          .            .          .           
.          .              .          .            .          .               printf("\n");
.          .              .          .            .          .           
.          .              .          .            .          .               // ----- ТЕСТ 2: произведение с нулевым многочленом -----
.          .              .          .            .          .               {
.          .              .          .            .          .                   test_count++;
.          .              .          .            .          .                   printf("[TEST 2] Произведение с нулевым многочленом\n");
.          .              .          .            .          .           
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0                   new_pol(&A, 0, 5);  // A = 0
.          .              .          .            .          .                   A.coeffs[0] = 0;
.          .              .          .            .          .           
0          0             24 ( 0.85%) 1 ( 2.50%)   0          0                   new_pol(&B, 2, 5);  // B = x^2 + 1
.          .              .          .            .          .                   B.coeffs[0] = 1; B.coeffs[1] = 0; B.coeffs[2] = 1;
.          .              .          .            .          .           
0          0             24 ( 0.85%) 1 ( 2.50%)   0          0                   new_pol(&M, 2, 5);  // M = x^2 + x + 1 (унитарный)
.          .              .          .            .          .                   M.coeffs[0] = 1; M.coeffs[1] = 1; M.coeffs[2] = 1;
.          .              .          .            .          .           
0          0             24 ( 0.85%) 1 ( 2.50%)  24 ( 0.85%) 1 ( 2.50%)          int result = pol_mul_mod_unit(&A, &B, &M, &R);
.          .              .          .            .          .           
.          .              .          .            .          .                   printf("  Вход: A=0, B=x^2+1, M=x^2+x+1 mod 5\n");
.          .              .          .            .          .                   printf("  Ожидаем: 0\n");
.          .              .          .            .          .                   printf("  Получили: "); print_polynomial(&R, "");
.          .              .          .            .          .                   printf("  Статус: %d", result);
.          .              .          .            .          .           
.          .              .          .            .          .                   int ok = (result == POL_SUCCESS && R.degree == 0 && R.coeffs[0] == 0);
.          .              .          .            .          .                   if (ok)
-- line 86 ----------------------------------------
-- line 88 ----------------------------------------
.          .              .          .            .          .                       printf(" -> ПРОЙДЕН\n");
.          .              .          .            .          .                       passed_count++;
.          .              .          .            .          .                   }
.          .              .          .            .          .                   else
.          .              .          .            .          .                   {
.          .              .          .            .          .                       printf(" -> ПРОВАЛ\n");
.          .              .          .            .          .                   }
.          .              .          .            .          .           
0          0              0          0           56 ( 1.98%) 3 ( 7.50%)          free_pol(&A); free_pol(&B); free_pol(&M);
.          .              .          .            .          .               }
.          .              .          .            .          .           
.          .              .          .            .          .               printf("\n");
.          .              .          .            .          .           
.          .              .          .            .          .               // ----- ТЕСТ 3: модуль степени 0 (M = 1) -----
.          .              .          .            .          .               {
.          .              .          .            .          .                   test_count++;
.          .              .          .            .          .                   printf("[TEST 3] Модуль степени 0 (M = 1)\n");
.          .              .          .            .          .           
0          0             16 ( 0.57%) 1 ( 2.50%)   0          0                   new_pol(&A, 1, 11);  // A = x + 2
.          .              .          .            .          .                   A.coeffs[0] = 2; A.coeffs[1] = 1;
.          .              .          .            .          .           
0          0             16 ( 0.57%) 1 ( 2.50%)   0          0                   new_pol(&B, 1, 11);  // B = x + 3
.          .              .          .            .          .                   B.coeffs[0] = 3; B.coeffs[1] = 1;
.          .              .          .            .          .           
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0                   new_pol(&M, 0, 11);  // M = 1 (унитарный)
.          .              .          .            .          .                   M.coeffs[0] = 1;
.          .              .          .            .          .           
0          0             72 ( 2.55%) 3 ( 7.50%)  80 ( 2.83%) 3 ( 7.50%)          int result = pol_mul_mod_unit(&A, &B, &M, &R);
.          .              .          .            .          .           
.          .              .          .            .          .                   printf("  Вход: A=x+2, B=x+3, M=1 mod 11\n");
.          .              .          .            .          .                   printf("  Ожидаем: 0 (любое число mod 1 = 0)\n");
.          .              .          .            .          .                   printf("  Получили: "); print_polynomial(&R, "");
.          .              .          .            .          .                   printf("  Статус: %d", result);
.          .              .          .            .          .           
.          .              .          .            .          .                   int ok = (result == POL_SUCCESS && R.degree == 0 && R.coeffs[0] == 0);
.          .              .          .            .          .                   if (ok)
-- line 123 ----------------------------------------
-- line 125 ----------------------------------------
.          .              .          .            .          .                       printf(" -> ПРОЙДЕН\n");
.          .              .          .            .          .                       passed_count++;
.          .              .          .            .          .                   }
.          .              .          .            .          .                   else
.          .              .          .            .          .                   {
.          .              .          .            .          .                       printf(" -> ПРОВАЛ\n");
.          .              .          .            .          .                   }
.          .              .          .            .          .           
0          0              0          0           40 ( 1.41%) 3 ( 7.50%)          free_pol(&A); free_pol(&B); free_pol(&M);
.          .              .          .            .          .               }
.          .              .          .            .          .           
.          .              .          .            .          .               printf("\n");
.          .              .          .            .          .           
.          .              .          .            .          .               // ----- ТЕСТ 4: M не унитарный -----
.          .              .          .            .          .               {
.          .              .          .            .          .                   test_count++;
.          .              .          .            .          .                   printf("[TEST 4] M не унитарный (старший коэффициент != 1)\n");
.          .              .          .            .          .           
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0                   new_pol(&A, 0, 7);  // A = 1
.          .              .          .            .          .                   A.coeffs[0] = 1;
.          .              .          .            .          .           
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0                   new_pol(&B, 0, 7);  // B = 1
.          .              .          .            .          .                   B.coeffs[0] = 1;
.          .              .          .            .          .           
0          0             16 ( 0.57%) 1 ( 2.50%)   0          0                   new_pol(&M, 1, 7);  // M = 2x + 1 (не унитарный, старший коэффициент 2)
.          .              .          .            .          .                   M.coeffs[0] = 1; M.coeffs[1] = 2;
.          .              .          .            .          .           
.          .              .          .            .          .                   int result = pol_mul_mod_unit(&A, &B, &M, &R);
.          .              .          .            .          .           
.          .              .          .            .          .                   printf("  Вход: A=1, B=1, M=2x+1 mod 7\n");
.          .              .          .            .          .                   printf("  Ожидаем: POL_INVALID_ARG (9, M не унитарный)\n");
.          .              .          .            .          .                   printf("  Статус: %d", result);
.          .              .          .            .          .           
.          .              .          .            .          .                   if (result == POL_INVALID_ARG) {
.          .              .          .            .          .                       printf(" -> ПРОЙДЕН\n");
.          .              .          .            .          .                       passed_count++;
.          .              .          .            .          .                   } else {
.          .              .          .            .          .                       printf(" -> ПРОВАЛ\n");
.          .              .          .            .          .                   }
.          .              .          .            .          .           
0          0              0          0           32 ( 1.13%) 3 ( 7.50%)          free_pol(&A); free_pol(&B); free_pol(&M);
.          .              .          .            .          .               }
.          .              .          .            .          .           
.          .              .          .            .          .               printf("\n");
.          .              .          .            .          .           
.          .              .          .            .          .               // ----- ТЕСТ 5: деление на нулевой многочлен -----
.          .              .          .            .          .               {
.          .              .          .            .          .                   test_count++;
.          .              .          .            .          .                   printf("[TEST 5] Деление на нулевой многочлен\n");
.          .              .          .            .          .           
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0                   new_pol(&A, 0, 13);  // A = 1
.          .              .          .            .          .                   A.coeffs[0] = 1;
.          .              .          .            .          .           
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0                   new_pol(&B, 0, 13);  // B = 1
.          .              .          .            .          .                   B.coeffs[0] = 1;
.          .              .          .            .          .           
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0                   new_pol(&M, 0, 13);  // M = 0
.          .              .          .            .          .                   M.coeffs[0] = 0;
.          .              .          .            .          .           
.          .              .          .            .          .                   int result = pol_mul_mod_unit(&A, &B, &M, &R);
.          .              .          .            .          .           
.          .              .          .            .          .                   printf("  Вход: A=1, B=1, M=0 mod 13\n");
.          .              .          .            .          .                   printf("  Ожидаем: POL_ZERO_DIV (5, деление на нулевой многочлен)\n");
.          .              .          .            .          .                   printf("  Статус: %d", result);
.          .              .          .            .          .           
-- line 189 ----------------------------------------
-- line 192 ----------------------------------------
.          .              .          .            .          .                       printf(" -> ПРОЙДЕН\n");
.          .              .          .            .          .                       passed_count++;
.          .              .          .            .          .                   }
.          .              .          .            .          .                   else
.          .              .          .            .          .                   {
.          .              .          .            .          .                       printf(" -> ПРОВАЛ\n");
.          .              .          .            .          .                   }
.          .              .          .            .          .           
0          0              0          0           24 ( 0.85%) 3 ( 7.50%)          free_pol(&A); free_pol(&B); free_pol(&M);
.          .              .          .            .          .               }
0          0              0          0           24 ( 0.85%) 1 ( 2.50%)      free_pol(&R);
.          .              .          .            .          .           
.          .              .          .            .          .               printf("\n=== ИТОГО: %d/%d тестов пройдено ===\n", passed_count, test_count);
.          .              .          .            .          .           
.          .              .          .            .          .               if (passed_count == test_count)
.          .              .          .            .          .               {
.          .              .          .            .          .                   return TEST_SUCCESS;
.          .              .          .            .          .               }
.          .              .          .            .          .               else
-- line 210 ----------------------------------------
-- line 219 ----------------------------------------
.          .              .          .            .          .           }
.          .              .          .            .          .           
.          .              .          .            .          .           int input_test()
.          .              .          .            .          .           {
.          .              .          .            .          .               char buffer[MAX_INPUT_LEN];
.          .              .          .            .          .               ULL modulo;
.          .              .          .            .          .           
.          .              .          .            .          .               printf("Enter modulo (integer > 1):\n");
0          0          1,024 (36.21%) 1 ( 2.50%)   0          0               if (scanf("%llu", &modulo) != 1 || modulo <= 1)
.          .              .          .            .          .               {
.          .              .          .            .          .                   return TEST_INVALID_MODULO;
.          .              .          .            .          .               }
.          .              .          .            .          .           
.          .              .          .            .          .               while (getchar() != '\n')
.          .              .          .            .          .               {;}
.          .              .          .            .          .           
.          .              .          .            .          .               Polynomial A, B, M, R;
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0               new_pol(&A, 0, modulo);
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0               new_pol(&B, 0, modulo);
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0               new_pol(&M, 0, modulo);
0          0              8 ( 0.28%) 1 ( 2.50%)   0          0               new_pol(&R, 0, modulo);
.          .              .          .            .          .           
.          .              .          .            .          .               printf("Enter polynomial A in format (a0,a1,...,an):\n");
.          .              .          .            .          .               if (!fgets(buffer, sizeof(buffer), stdin))
.          .              .          .            .          .               {
.          .              .          .            .          .                   return TEST_INVALID_ARG;
.          .              .          .            .          .               }
.          .              .          .            .          .               buffer[strcspn(buffer, "\n")] = '\0';
.          .              .          .            .          .           
0          0             80 ( 2.83%) 2 ( 5.00%)  48 ( 1.70%) 2 ( 5.00%)      int status = str_to_pol(buffer, modulo, &A);
.          .              .          .            .          .               if (status != POL_SUCCESS)
.          .              .          .            .          .               {
.          .              .          .            .          .                   return TEST_INVALID_ARG;
.          .              .          .            .          .               }
.          .              .          .            .          .           
.          .              .          .            .          .               printf("Enter polynomial B in format (b0,b1,...,bn):\n");
.          .              .          .            .          .               if (!fgets(buffer, sizeof(buffer), stdin))
.          .              .          .            .          .               {
.          .              .          .            .          .                   free_pol(&A);
.          .              .          .            .          .                   return TEST_INVALID_ARG;
.          .              .          .            .          .               }
.          .              .          .            .          .               buffer[strcspn(buffer, "\n")] = '\0';
.          .              .          .            .          .           
0          0             48 ( 1.70%) 2 ( 5.00%)  32 ( 1.13%) 2 ( 5.00%)      status = str_to_pol(buffer, modulo, &B);
.          .              .          .            .          .               if (status != POL_SUCCESS)
.          .              .          .            .          .               {
.          .              .          .            .          .                   free_pol(&A);
.          .              .          .            .          .                   return TEST_INVALID_ARG;
.          .              .          .            .          .               }
.          .              .          .            .          .           
.          .              .          .            .          .               printf("Enter unitary modulus M in format (m0,m1,...,1):\n");
.          .              .          .            .          .               if (!fgets(buffer, sizeof(buffer), stdin))
.          .              .          .            .          .               {
.          .              .          .            .          .                   free_pol(&A);
.          .              .          .            .          .                   free_pol(&B);
.          .              .          .            .          .                   return TEST_INVALID_ARG;
.          .              .          .            .          .               }
.          .              .          .            .          .               buffer[strcspn(buffer, "\n")] = '\0';
.          .              .          .            .          .           
0          0             16 ( 0.57%) 2 ( 5.00%)  16 ( 0.57%) 2 ( 5.00%)      status = str_to_pol(buffer, modulo, &M);
.          .              .          .            .          .               if (status != POL_SUCCESS)
.          .              .          .            .          .               {
.          .              .          .            .          .                   free_pol(&A);
.          .              .          .            .          .                   free_pol(&B);
.          .              .          .            .          .                   return TEST_INVALID_ARG;
.          .              .          .            .          .               }
.          .              .          .            .          .           
.          .              .          .            .          .               if (M.degree == 0 && M.coeffs[0] == 0)
-- line 286 ----------------------------------------
-- line 294 ----------------------------------------
.          .              .          .            .          .               if (M.coeffs[M.degree] != 1)
.          .              .          .            .          .               {
.          .              .          .            .          .                   free_pol(&A);
.          .              .          .            .          .                   free_pol(&B);
.          .              .          .            .          .                   free_pol(&M);
.          .              .          .            .          .                   return TEST_INVALID_ARG;
.          .              .          .            .          .               }
.          .              .          .            .          .           
0          0            168 ( 5.94%) 3 ( 7.50%) 120 ( 4.24%) 3 ( 7.50%)      status = pol_mul_mod_unit(&A, &B, &M, &R);
.          .              .          .            .          .           
0          0              0          0           40 ( 1.41%) 1 ( 2.50%)      free_pol(&A);
0          0              0          0           24 ( 0.85%) 1 ( 2.50%)      free_pol(&B);
0          0              0          0            8 ( 0.28%) 1 ( 2.50%)      free_pol(&M);
.          .              .          .            .          .           
.          .              .          .            .          .               if (status != POL_SUCCESS)
.          .              .          .            .          .                   return TEST_UNKNOWN_ERROR;
.          .              .          .            .          .           
.          .              .          .            .          .               char* str_result = NULL;
0          0              4 ( 0.14%) 1 ( 2.50%)   0          0               status = pol_to_str(&R, &str_result);
.          .              .          .            .          .               if (status != POL_SUCCESS)
.          .              .          .            .          .               {
.          .              .          .            .          .                   free_pol(&R);
.          .              .          .            .          .                   return TEST_MEMORY_ERROR;
.          .              .          .            .          .               }
.          .              .          .            .          .           
.          .              .          .            .          .               printf("Result: %s\n", str_result);
.          .              .          .            .          .           
0          0              0          0            4 ( 0.14%) 1 ( 2.50%)      free(str_result);
0          0              0          0           56 ( 1.98%) 1 ( 2.50%)      free_pol(&R);
.          .              .          .            .          .           
.          .              .          .            .          .               return TEST_SUCCESS;
.          .              .          .            .          .           }
--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./csu/../sysdeps/nptl/libc_start_call_main.h
  ./libio/./libio/filedoalloc.c
  ./libio/./libio/fileops.c
  ./libio/./libio/genops.c
  ./libio/./libio/ioputs.c
  ./malloc/./malloc/set-freeres.c
  ./stdio-common/./stdio-common/isoc99_scanf.c
  ./stdio-common/./stdio-common/vfscanf-internal.c
  ./stdlib/./stdlib/exit.c
  UnknownFile???

--------------------------------------------------------------------------------
curB       curBk      totB           totBk        totFdB         totFdBk      
--------------------------------------------------------------------------------
0          0          6,908 (100.0%) 131 (100.0%) 2,680 (94.77%) 126 (100.0%)  events annotated

